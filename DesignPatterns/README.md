# 设计相关

​	面向对象有3大特性（继承，封装，多态），6大原则（单一职责原则，开闭原则，里斯替换原则，依赖倒置原则，接口隔离，迪米特原则，简称SOLIDD原则），23种设计模式。简称面向对象的3623。使用设计模式和设计原则的根本目的是追求高内聚，低耦合，高复用性，使软件更有可维护性和可扩展性。

总体结构图如下：

![Design](https://cdn.jsdelivr.net/gh/HolaAmigoV5/Images/Design/Design.png)

## 设计模式

### 创建型模式

#### 单例模式		:star::star:

​	一个类只有一个实例，并提供一个访问它的全局访问点。

#### 简单工厂模式		:star::star::star:

​	工厂类负责对象的创建，使客户端不再依赖具体的对象，实现代码的复用。缺点是工厂类会出现单点故障，使系统不可用。系统扩展困难，一旦新添加，就得修改工厂逻辑。

**应用实例**：System.Text.Encoding类就实现了简单工厂模式。

#### 工厂方法模式		:star::star::star:

​	每个对象的生产都有对应的工厂创建。主要构成有抽象工厂类，具体工厂类，抽象产品类和具体产品类。对比抽象工厂模式，方法工厂模式创建产品单一而抽象工厂模式能创建更多产品。

#### 抽象工厂模式 	:star::star::star:

​	提供一个创建产品的接口来负责创建相关或依赖的对象，而不具体明确指定具体类。缺点是很难支持新种类产品的变化，因为抽象工厂已经确定了被创建产品的集合。相比简单工厂模式，对工厂类进行了抽象，不再依赖单一工厂，扩展性更强。

**应用实例**：System.Data.Common.DbProviderFactory。

#### 建造者模式		:star::star::star:

​	指挥者调度具体的建造者去建造对象。主要用于分步骤构建一个复杂的对象。主要构成有指挥者，抽象建造者，具体建造者，建造对象。

**应用实例**：System.Text.StringBuilder

#### 原型模式		:star::star:

​	通过Clone的方式复制已有对象，而又无需使用代码依赖它们所属的类。主要构成有抽象原型和具体原型。优点是简化了实例的创建结构。缺点是克隆包含循环引用的复杂对象可能会非常麻烦。

### 结构型模式

####  适配器模式		:star::star::star:

​	使接口不兼容的对象能够相互合作。包含类的适配器模式和对象的适配器模式。类的适配器模式通过继承的方式实现适配，而对象的适配器模式则是在适配器中new一个对象，然后调用。

**适用场景**：系统需要复用现有类，而该类不符合系统需要。

**应用实例**：DataAdapter类是实现

#### 桥接模式		:star:

​	将一个大类或一系列紧密相关的类拆分为**抽象和实现两个对立的层次结构**，从而能在开发时分别使用。本质是通过将继承改为组合的方式来解决问题。优点是抽象和实现可单独扩展，互不影响。缺点是增加了系统的复杂度。

**适用场景**：① 拆分或重组一个具体多重功能的庞杂类；② 希望在几个独立维度上扩展一个类；③ 需要在运行时切换不同的实现方法。

**应用实例**： 三层架构中业务层BLL中通过桥接模式与数据操作层解耦(DAL)。

#### 装饰者模式		:star::star:

​	为解决“子类爆炸”问题，使用装饰者模式动态地给一个对象添加额外的职责。主要由抽象构件，具体构件，装饰者和具体装饰者。优点是装饰者模式目的是扩展对象的功能，比继承更灵活；可以通过不同的排列组合创造出很多不同行为的组合，扩展性好。缺点是装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变得更复杂。

**适用场景**：需要扩展一个类的功能或给一个类增加附加责任；需要动态地给一个对象增加功能；需要增加由一些基本功能的排列组合而产生非常大量的功能。

**应用实例**：System.IO.Stream就是使用的装饰者模式。

#### 组合模式		:star::star:

​	可以使用组合模式将对象组合成树状结构，并且能像使用独立对象一样使用它们。构成有抽象构件，树枝构件和树叶构件。优点是组合模式使得客户端代码可以一致地处理对象和对象容器。缺点是设计更复杂。

**适用场景**：需要表示一个对象整体或部分的层次结构。

#### 外观模式		:star::star:

​	能为程序库、框架或其他复杂类提供一个简单的接口。相比适配器模式，适配器模式是对一个接口包装适应需要，而外观模式是将一群对象“包装”起来以简化其接口。构成有门面(Facade)和子系统(subsystem)。优点是外观模式对客户屏蔽了子系统组件，从而简化了接口；实现了子系统与客户之间的松耦合关系。缺点是如果增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

**适用场景**：为一个复杂的子系统提供一个简单的接口。

#### 享元模式		:star:

​	运用共享技术有效的支持大量细粒度的对象。实际开发不常用，作为底层提升性能的一种手段。构成有抽象享元角色，具体享元角色，享元工厂角色和客户端角色。优点是降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力，从而降低了系统中细粒度对象给内存带来的压力。缺点是为了使对象可以共享，需要一些状态外部化，使得程序的逻辑更复杂；享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

**适用场景（所有条件满足）**：① 一个系统中有大量的对象，这些对象消耗大量的内存；② 这些对象中的状态大部分都可以被外部化，可以按照内部状态分很多组，当把外部对象从对象中剔除，每个组都可以仅用一个对象代替；③ 软件系统不依赖这些对象的身份。

#### 代理模式		:star:

​	简单说就是找个中介帮忙处理事务。主要构成有抽象主题角色，代理主题角色和真实主题角色三类。优点是代理模式能够将调用用于真正被调用对象隔离，降低耦合度，同时对目标对象保护。缺点是客户端和真实主题之间增加了一个代理对象，造成请求处理速度慢，也增加了系统的复杂度。





### 行为型模式

#### 模板方法模式		:star::star:

​	实质是抽象类中定义一个或多个抽象操作，子类来实现这些抽象操作。其实就是继承实现代码的复用。主要构成有抽象模板和具体模板两类。优点是能实现代码的复用，也能灵活应对子步骤的变化。

**实际应用**：自定义控件时，只需要重写某个控件的部分方法。

#### 命令模式		:star::star::star:

​	依赖于命令的接收者，在抽象命令Action()方法中调用Receiver的实际动作。主要构成有命令抽象类，命令接收者，命令调用者。

**使用场景**：系统支持命令撤销，需要在不同的时间指定请求，将请求排队。

#### 迭代器模式		:star::star::star:

​	主要构成有迭代器抽象对象和聚合抽象对象。优点是访问一个聚合对象的内容而无需暴露它内部的表示，遍历不同的集合结构提供了统一的接口，从而支持同样的算法在不同的集合结构上操作。缺点是遍历时更改迭代器所在集合结构会导致出现异常。

**适用场景**：系统需要支持对聚合对象的多种遍历，需要为不同的聚合提供一个统一的接口。

**应用实例**：IEnumerator就是迭代器角色，IEnumberable就是抽象聚合对象。

#### 观察者模式		:star::star::star:

​	实际就是订阅发布模式。主要构成有观察者(订阅者)和被观察者(发布者)。优点是观察者和被观察者之间建立一个抽象耦合，支持广播通信，被观察者会向所有注册过的观察者发出通知。缺点是① 通知所有订阅者可能比较耗时；②没有一种机制告知观察者发生的变化；③如果被观察者之间有循环依赖的话，可能会循环调用，导致系统崩溃。

**适用场景**：当一个对象的改变需要同时改变其他对象，而又不知道具体有多少对象待改变时。

#### 中介者模式		:star::star:

​	中介者模式能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。主要包括抽象中介者和抽象对象。优点是简化了对象之间的关系，将系统的各个对象之间关系进行封装，使系统松耦合，更灵活。缺点是中介者承担较多责任，容易造成单点故障；新增一个同事类时，不得不去修改抽象中介者和具体中介者，此时需要使用观察者模式和状态模式解决这个问题。

**适用场景**：一组定义良好的对象，现在要进行复杂的相互通信；想通过一个中间类来封装多个类中的行为，而又不想生太多的子类。

#### 状态者模式		:star::star:

​	本质是状态多变，把状态判断逻辑放在各个状态类里面，简化判断逻辑。让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变自身所属的类一样。优点是将状态判断逻辑放在每个状态类中，简化了判断逻辑；当新的状态出现时，可以通过添加新的状态来扩展，扩展性好。缺点是如果状态过多，会导致非常多的状态类，加大了开销。

**应用场景**：① 当一个对象状态转换条件过于复杂时使用；② 当一个对象的行为取决于它的状态，并且它需要在运行时根据状态改变它的行为时使用。

#### 策略者模式		:star::star::star:

​	策略模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。主要构成有上下文，策略和具体策略。优点是策略之间可以自由切换，易于扩展。缺点是客户端必须知道所有策略，并自行决定使用哪种策略。

**应用实例**： List\<T>.Sort(IComparer\<T>)的实现。

**适用场景**： 一个系统需要动态在几种算法中选择一种；如果一个对象有很多行为，有很多if-else场景使用。

#### 责任链模式		:star:

​	允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下一个处理者。主要构成有抽象处理者和具体处理者角色。优点是降低了请求发送者和接收者之间的耦合，把多个条件判定分散到各个处理类中，使代码更加清晰，责任更明确。缺点是当执行链过长时，会引起性能问题；也可能导致某个请求不被处理。

**适用场景**：一个系统的审批需要多个对象才能完成处理的情况；代码中存在多个if-else语句情况，可以考虑此模式重构。

#### 访问者模式 		:star:

​	本质是用来封装一些施加于某种数据结构之上的操作。它使得可以不改变元素本身的前提下增加作用于这些元素新操作，其目的是把操作从数据结构中分离出来。主要包括抽象访问者，抽象节点角色，结构对象角色。优点是添加新操作容易；缺点是增加新元素困难。

**应用场景**：① 如果系统有比较稳定的数据结构，而又有易于变化的算法时使用；② 如果一组中存在相似的操作，为了代码重用，可以考虑把重复操作封装在访问者中；③ 如果一个对象存在着一些与本身对象不相干或关系比较弱的操作时。

#### 备忘录模式		:star:

​	在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后就可以恢复原先状态。主要构成有发起人角色，备忘录角色，管理者角色。优点是可以恢复被破坏的数据。发起人不需要对各个备份状态进行管理，而是由备忘录角色进行管理。缺点是需要维护多个备份，需要额外的资源，资源消耗比较严重。

**适用场景**：如果系统需要提供回滚操作，使用备忘录模式非常合适。



## 设计原则

​	面向对象的6大设计原则，简称SOLIDD原则。详情如下：

### 单一职责原则(S)

​	Single Reponsibility Principle, SRP。一个类只负责一项职责，就一个类而言，应该只有一个引起它变化的原因。

### 开闭原则(O)

​	 Open Closed Principle, OCP。对扩展开发，对修改封闭。为适应不断的需求变化，不应该修改原有实现代码，而是通过扩展来实现变化的需求。

### 里氏替换原则(L)

​	Liskov Substitution Principle, LSP。所有使用基类的地方，都可以使用子类来代替，而且行为不会有任何变化。简单说：老子能干，儿子也能干。

### 接口隔离原则(I)

​	Interface Segregation Principe, ISP。类的依赖关系应建立在最小接口上，不要都塞在一起。客户端不应该依赖它不需要的接口。简单说就是接口纯粹，该提供的提供，不该提供的隐藏。

### 依赖倒置原则(D)

​	Dependence Inversion Principle, DIP。高层模块不应该依赖低层模块，两者都应该依赖其抽象，不要依赖细节。抽象指接口或抽象类，两者都不能直接进行实例化，细节就是实现了接口或继承了抽象类的实现类。本质是，程序逻辑在传递参数或关联关系时，尽量使用接口或抽象类来引用参数，声明变量以及处理返回值。简单说就是面向抽象编程。

### 迪米特法则(D)

​	Law of Demeter, LOD 或Least Knowledge Principle, LKP。一个对象应尽可能少了解其它对象。类与类之间，我不管你的实现细节，我只管调用。
